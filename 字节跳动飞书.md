# 字节飞书后端一面

## TCP 三次握手与四次挥手?

![avatar](./pics/20210302170145512.png)\
Seq：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号\
ACK：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段\
SYN：同步序号，为 1 表示连接请求，用于建立连接和使序列号同步\
FIN：用于释放连接，为 1 表示发送方没有数据发送了，关闭本方数据流

### 三次握手 类似表白--双工

![avatar](./pics/三次握手.png)\
**第一次握手**
客服端给服务器发送一个 SYN 报文\
`客服端发送功能正常`\
client: SYN_SEND server: LISTEN\
**第二次握手**
服务端收到 SYN 报文，回复 SYN + ACK 报文\
`client:发送功能正常, server:接收、发送功能正常`\
client: SYN_SEND server: SYN_RCVD\
**第三次握手**
客户端收到 SYN + ACK 报文之后，回应 ACK 报文\
`客户端的接收、发送能力正常，服务器的发送、接收能力正常`\
client: established server: established

**半连接队列**：

服务器处于 SYN_RCVD 状态，双方还`未完全建立连接`，服务器会把这种状态下的请求`放到半连接队列`。完成`三次握手`的连接所在的队列为`全连接队列`，如果队列满了可能会发生丢包现象。

### 四次挥手 类似挂电话

![avatar](./pics/20210302200827357.png)

**客户端-发送一个 FIN** 用来关闭客户端到服务器的数据传送\
客户端：FIN_WAIT1 [等待远程TCP中断请求]&nbsp;&nbsp;&nbsp;&nbsp;服务端：ESTABLISHED

**服务器-收到这个 FIN** 它发回一个ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号\
客户端：FIN_WAIT1 [等待远程TCP中断请求]&nbsp;&nbsp;&nbsp;&nbsp;服务端：CLOSE_WAIT

**服务器-关闭与客户端的连接** 发送一个FIN给客户端\
客户端：FIN_WAIT2[从远程TCP等待连接中断请求]&nbsp;&nbsp;&nbsp;&nbsp;服务端：LAST_ACK[等待中断请求的确认]

**客户端-发回 ACK 报文确认** 并将确认序号设置为收到序号加1\
客户端：等待2MSL(TIME_WAIT)-->CLOSED&nbsp;&nbsp;&nbsp;&nbsp;服务端：CLOSED[没有任何连接]

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

## OSI模型?

![avatar](./pics/七层体系结构图.gif)

## 链路层和物理层的作用?

**物理层(physical layer)的作用** 透明传送比特流表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

**数据链路层** 两台主机之间的数据传输,总是在一段一段的链路上传送的, 数据链路层将网络层交下来的 IP 数据报组装成帧.

## 数据库三大范式？

**第一范式** 列[属性]不可再分

**第二范式** 行可以唯一区分，主键约束

**第三范式** 表的非主属性不能依赖与其他表非主属性 外键约束

## 数据库数据较多的时候怎么处理？

创建索引

## 索引越多越好？

1、合理的建立索引能够加速数据读取效率，不合理的建立索引反而会拖慢数据库的响应速度。\
2、`索引越多`，更新数据的速度`越慢`。

## SpringBoot、Spring和Spring MVC区别 ?

**Spring**最重要的特征是DI(依赖注入).所有SpringModules不是依赖注入就是IOC控制反转。当我们恰当使用DI或者IOC的时候，可以开发低耦合的应用。\
**Spring MVC**

## Spring AOP？

面向对象编程是


